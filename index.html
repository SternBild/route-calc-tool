<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>路程計算ツール</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
body {
    margin: 0;
    padding: 20px;
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
}
#container {
    max-width: 1400px;
    margin: 0 auto;
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 20px;
}
h1 {
    text-align: center;
    color: #333;
    margin: 0 0 30px 0;
    font-size: 28px;
    position: relative;
}
#printButton {
    position: absolute;
    top: 0;
    right: 0;
    padding: 8px 16px;
    background-color: #6c757d;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}
#printButton:hover {
    background-color: #5a6268;
}
#version {
    font-size: 16px;
    color: #6c757d;
    font-weight: normal;
    margin-left: 15px;
    margin-right: 15px;
}
#mainContainer {
    display: flex;
    gap: 20px;
    align-items: flex-start;
}
#mapContainer {
    flex-shrink: 0;
    position: relative;
}
canvas { 
    border: 1px solid #ccc;
    cursor: grab;
}
canvas:active {
    cursor: grabbing;
}
#zoomInfo {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    color: #333;
    border: 1px solid #ccc;
    pointer-events: none;
}
#rightPanel {
    min-width: 300px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#info { 
    padding: 15px;
    background-color: #e8f4fd;
    border-radius: 8px;
    border: 1px solid #b3d9f2;
    font-size: 14px;
    line-height: 1.4;
}
#info h4 {
    margin: 0 0 10px 0;
    color: #0056b3;
    font-size: 16px;
}
#controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid #ddd;
}
#controls h4 {
    margin: 0 0 10px 0;
    color: #333;
    font-size: 16px;
}
#controls button {
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    background-color: #007bff;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}
#controls button:hover:not(:disabled) {
    background-color: #0056b3;
}
#controls button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}
#roadOptions {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid #ddd;
}
#roadOptions h4 {
    margin: 0 15px 0 0;
    color: #333;
    font-size: 16px;
}
#roadOptions label {
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    color: #333;
}
#roadOptions input[type="checkbox"] {
    margin: 0;
}
#operationInfo {
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
    font-size: 12px;
    color: #666;
}
#operationInfo h4 {
    margin: 0 0 5px 0;
    color: #495057;
    font-size: 14px;
}
#result {
    width: 100%;
    overflow-x: auto;
    margin-top: 20px;
    border-top: 1px solid #ddd;
    padding-top: 20px;
}
#resultHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 10px 0;
    border-bottom: 2px solid #ddd;
}
#resultHeader h3 {
    margin: 0;
    color: #333;
}
#showAllPathsBtn {
    padding: 8px 16px;
    border: none;
    border-radius: 5px;
    background-color: #007bff;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}
#showAllPathsBtn:hover:not(:disabled) {
    background-color: #0056b3;
}
#showAllPathsBtn:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}
#showAllPathsBtn.active {
    background-color: #28a745;
}
#showAllPathsBtn.active:hover {
    background-color: #1e7e34;
}
.path-list {
    margin: 10px 0;
}
.path-item {
    margin: 5px 0;
    padding: 10px;
    border-radius: 5px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0.4;
}
.path-item:hover {
    opacity: 0.7;
    transform: translateY(-1px);
}
.path-item.rank-1 {
    background-color: #fff3cd;
    border-color: #ffeaa7;
}
.path-item.rank-2 {
    background-color: #e7f3ff;
    border-color: #add8e6;
}
.path-item.rank-3 {
    background-color: #f0f8e7;
    border-color: #90ee90;
}
.path-item.selected {
    opacity: 1.0;
    border-color: #ff6b6b;
    box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
    font-weight: bold;
}
.path-item.selected:hover {
    opacity: 1.0;
    transform: none;
}
.rank-badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 12px;
    font-weight: bold;
    margin-right: 5px;
}
.rank-1-badge { background-color: #ffd700; color: #333; }
.rank-2-badge { background-color: #c0c0c0; color: #333; }
.rank-3-badge { background-color: #cd7f32; color: white; }
.selected-indicator {
    color: #ff6b6b;
    font-weight: bold;
    margin-left: 10px;
}
@media print {
    body {
        padding: 0;
        margin: 0;
        background: white;
        font-size: 10px;
    }
    #container {
        max-width: none;
        width: 100%;
        padding: 5px 10px 5px 10px;
        box-shadow: none;
        border-radius: 0;
        background: white;
    }
    h1 {
        font-size: 18px;
        margin: 0 0 5px 0;
        text-align: center;
    }
    #printButton {
        display: none;
    }
    #mainContainer {
        display: flex !important;
        flex-direction: row !important;
        gap: 10px;
        align-items: flex-start;
        margin: 5px 0;
    }
    #mapContainer {
        flex-shrink: 0;
        width: 80%;
    }
    canvas {
        width: 100%;
        max-width: 100%;
        height: auto;
        border: 1px solid #000;
    }
    #zoomInfo {
        display: none;
    }
    #rightPanel {
        width: 18%;
        min-width: 150px;
        gap: 6px;
        display: flex !important;
        flex-direction: column !important;
    }
    #info {
        padding: 8px;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        margin-bottom: 8px;
    }
    #info h4 {
        font-size: 12px;
        margin: 0 0 5px 0;
    }
    #info div {
        font-size: 10px;
        line-height: 1.3;
    }
    #controls, #operationInfo {
        display: none;
    }
    #roadOptions {
        padding: 8px;
        background-color: #f5f5f5;
        border: 1px solid #ccc;
        margin-bottom: 8px;
    }
    #roadOptions h4 {
        font-size: 12px;
        margin: 0 0 5px 0;
    }
    #roadOptions label {
        font-size: 10px;
    }
    #result {
        margin-top: 10px;
        margin-bottom: 5px;
        padding-top: 10px;
        border-top: 1px solid #000;
        page-break-inside: avoid;
    }
    #resultHeader {
        margin-bottom: 8px;
        padding: 0;
        border-bottom: 1px solid #ccc;
    }
    #resultHeader h3 {
        font-size: 14px;
        margin: 0 0 5px 0;
    }
    #showAllPathsBtn {
        display: none;
    }
    .path-list {
        margin: 5px 0;
    }
    .path-list h4 {
        font-size: 15px;
        margin: 0 0 6px 0;
    }
    .path-item {
        padding: 8px;
        margin: 4px 0;
        font-size: 13px;
        line-height: 1.4;
        border: 1px solid #ccc;
        background-color: white;
    }
    .path-item.selected {
        border: 2px solid #000;
        font-weight: bold;
    }
    .rank-badge {
        font-size: 12px;
        padding: 3px 6px;
        border: 1px solid #000;
        background-color: white;
        color: black;
    }
    .selected-indicator {
        color: #000;
    }
}
.pdf-generation {
    padding: 0;
    margin: 0;
    background: white;
    font-size: 10px;
}
.pdf-generation #container {
    max-width: none;
    width: 100%;
    padding: 5px 10px 5px 10px;
    box-shadow: none;
    border-radius: 0;
    background: white;
}
.pdf-generation h1 {
    font-size: 18px;
    margin: 0 0 5px 0;
    text-align: center;
}
.pdf-generation #printButton {
    display: none;
}
.pdf-generation #mainContainer {
    display: flex;
    flex-direction: row;
    gap: 10px;
    align-items: flex-start;
    margin: 5px 0;
}
.pdf-generation #mapContainer {
    flex-shrink: 0;
    width: 80%;
}
.pdf-generation canvas {
    width: 100%;
    max-width: 100%;
    height: auto;
    border: 1px solid #000;
}
.pdf-generation #zoomInfo {
    display: none;
}
.pdf-generation #rightPanel {
    width: 18%;
    min-width: 150px;
    gap: 6px;
    display: flex;
    flex-direction: column;
}
.pdf-generation #info {
    padding: 8px;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    margin-bottom: 8px;
}
.pdf-generation #info h4 {
    font-size: 12px;
    margin: 0 0 5px 0;
}
.pdf-generation #info div {
    font-size: 10px;
    line-height: 1.3;
}
.pdf-generation #controls,
.pdf-generation #operationInfo {
    display: none;
}
.pdf-generation #roadOptions {
    padding: 8px;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    margin-bottom: 8px;
}
.pdf-generation #roadOptions h4 {
    font-size: 12px;
    margin: 0 0 5px 0;
}
.pdf-generation #roadOptions label {
    font-size: 10px;
}
.pdf-generation #result {
    margin-top: 10px;
    margin-bottom: 5px;
    padding-top: 10px;
    border-top: 1px solid #000;
}
.pdf-generation #resultHeader {
    margin-bottom: 8px;
    padding: 0;
    border-bottom: 1px solid #ccc;
}
.pdf-generation #resultHeader h3 {
    font-size: 14px;
    margin: 0 0 5px 0;
}
.pdf-generation #showAllPathsBtn {
    display: none;
}
.pdf-generation .path-list {
    margin: 5px 0;
}
.pdf-generation .path-list h4 {
    font-size: 11px;
    margin: 0 0 3px 0;
}
.pdf-generation .path-item {
    padding: 5px;
    margin: 2px 0;
    font-size: 9px;
    line-height: 1.2;
    border: 1px solid #ccc;
    background-color: white;
}
.pdf-generation .path-item.selected {
    border: 2px solid #000;
    font-weight: bold;
}
.pdf-generation .rank-badge {
    font-size: 9px;
    padding: 1px 3px;
    border: 1px solid #000;
    background-color: white;
    color: black;
}
.pdf-generation .selected-indicator {
    color: #000;
}
@media (max-width: 1400px) {
    body {
        padding: 10px;
    }
    #container {
        margin: 0;
        border-radius: 5px;
    }
}
@media (max-width: 1200px) {
    #mainContainer {
        flex-direction: column;
    }
    #rightPanel {
        min-width: auto;
        width: 100%;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 10px;
    }
    #rightPanel > div {
        flex: 1;
        min-width: 200px;
    }
    #controls {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
    }
    #controls button {
        flex: 1;
        min-width: 120px;
    }
    #mapContainer canvas {
        max-width: 100%;
        height: auto;
    }
}
@media (max-width: 800px) {
    #container {
        padding: 10px;
    }
    #rightPanel {
        flex-direction: column;
    }
    #controls {
        flex-direction: column;
    }
    #controls button {
        width: 100%;
        margin: 2px 0;
    }
    #roadOptions {
        flex-direction: column;
        align-items: stretch;
    }
    #roadOptions h4 {
        margin: 0 0 10px 0;
        color: #333;
    }
    #roadOptions label {
        justify-content: flex-start;
        color: #333;
    }
    #resultHeader {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
    }
    #resultHeader h3 {
        text-align: center;
    }
}
@media (max-width: 600px) {
    body {
        padding: 5px;
    }
    h1 {
        font-size: 24px;
        margin-bottom: 20px;
    }
    #mapContainer canvas {
        width: 100%;
        height: auto;
    }
}
</style>
</head>
<body>
<div id="container">
<h1>路程計算ツール
    <span id="version">v1.2</span>
    <button id="printButton" onclick="printPDF()">PDF出力</button>
</h1>
<div id="mainContainer">
    <div id="mapContainer">
        <canvas id="map" width="1000" height="640"></canvas>
        <div id="zoomInfo">倍率: 100%</div>
    </div>
    <div id="rightPanel">
        <div id="info">
            <h4>選択地点</h4>
            <div>出発地点: <span id="startNode">未選択</span></div>
            <div>中継地点: <span id="viaNodeList">なし</span></div>
            <div>到着地点: <span id="endNode">未選択</span></div>
        </div>
        <div id="controls">
            <h4>操作</h4>
            <button onclick="calculatePath()">経路を計算</button>
            <button onclick="clearAll()">選択地点をクリア</button>
            <button onclick="resetView()">表示位置リセット</button>
        </div>
        <div id="roadOptions">
            <h4>設定</h4>
            <label><input type="checkbox" id="avoidMountain" checked> 山道を使用しない</label>
            <label><input type="checkbox" id="carFare30" checked> 車賃単価30円</label>
        </div>
        <div id="operationInfo">
            <h4>操作方法</h4>
            <div style="font-size: 12px; line-height: 1.4;">
                <div style="margin-bottom: 8px;"><strong>地点選択：</strong> 地図上の地点をクリックして出発地点、到着地点、中継地点を選択</div>
                <div style="margin-bottom: 8px;"><strong>地図操作：</strong> マウスホイールで拡大縮小、ドラッグで地図移動</div>
                <div style="margin-bottom: 8px;"><strong>経路計算：</strong> 出発地点と到着地点を選択後、「経路を計算」ボタンをクリック</div>
                <div style="margin-bottom: 8px;"><strong>経路選択：</strong> 複数の経路候補から任意の経路をクリックして選択・表示</div>
                <div style="margin-bottom: 8px; padding: 8px; background-color: #fff3cd; border-radius: 4px; border: 1px solid #ffeaa7;">
                    <strong style="color: #856404;">注意：</strong> <span style="color: #856404;">中継地点は最大5つまで選択可能です。中継地点を選択した場合は、最短距離の経路のみが計算されます</span>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="result"></div>
</div>

<script>
const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");
const viaNodes = [];
const MAX_VIA = 5;

// 高解像度対応
const devicePixelRatio = window.devicePixelRatio || 1;
const canvasWidth = 1000;
const canvasHeight = 640;

// 高解像度対応でキャンバスを設定
canvas.width = canvasWidth * devicePixelRatio;
canvas.height = canvasHeight * devicePixelRatio;
canvas.style.width = canvasWidth + 'px';
canvas.style.height = canvasHeight + 'px';
ctx.scale(devicePixelRatio, devicePixelRatio);

// ビュー変換パラメータ
let viewState = {
    scale: 1.0,
    translateX: 0,
    translateY: 0,
    isDragging: false,
    lastMouseX: 0,
    lastMouseY: 0
};

const nodes = {
"楯岡": [339, 403],
"東沢": [395, 418],
"村山浄化センター": [327, 479],
"湯沢": [380, 366],
"北町": [355, 346],
"名取": [321, 310],
"浮沼": [288, 345],
"清水": [305, 243],
"河島": [282, 435],
"大淀": [251, 287],
"伝承館": [259, 391],
"碁点": [237, 437],
"行沢": [398, 255],
"大上林崎": [355, 291],
"中沢": [436, 214],
"新山": [439, 282],
"金谷": [355, 240],
"大久保": [204, 511],
"湯野沢": [152, 516],
"払平": [116, 578],
"岩野": [118, 464],
"葉山キャンプ場": [51, 439],
"大槇": [233, 365],
"稲下": [200, 439],
"長善寺": [169, 393],
"樽石": [125, 402],
"洗馬中": [91, 346],
"ふれあいの里": [57, 303],
"白鳥": [184, 321],
"宮下": [160, 263],
"長島": [203, 204],
"本飯田": [355, 144],
"土生田": [355, 81],
"赤石高玉": [312, 73],
"五十沢": [404, 33],
"境ノ目": [283, 178],
"小滝": [252, 199],
"深沢": [182, 135],
"　森　": [246, 133],
"富並": [200, 84],
"下小屋": [126, 73],
"枡沢": [110, 121],
"大石": [91, 72],
"清水平": [74, 150],
"上平": [44, 150],
"大鳥居": [54, 36],
"三枚平": [12, 93]
};

// 隠し地点の設定（経路計算には使用するが、表示・選択はできない）
const hiddenNodes = {
    // "隠し地点1": [400, 300],  // このような形で追加可能
    // "隠し地点2": [200, 150]   // 複数追加可能
};

// 全ての地点（通常の地点 + 隠し地点）
const allNodes = { ...nodes, ...hiddenNodes };

// 道路情報の定義
const roadTypes = {
    "default": { color: "black", lineWidth: 1, style: "solid" },
    "highway": { color: "red", lineWidth: 3, style: "solid" },
    "prefectural": { color: "blue", lineWidth: 2, style: "solid" },
    "city": { color: "green", lineWidth: 1.5, style: "solid" },
    "mountain": { color: "brown", lineWidth: 1, style: "dashed" },
    "river": { color: "cyan", lineWidth: 1, style: "dotted" }
};

const edges = [
["楯岡", "東沢", 4, "city"],
["楯岡", "村山浄化センター", 5, "city"],
["楯岡", "湯沢", 3, "prefectural"],
["楯岡", "北町", 3, "city"],
["楯岡", "名取", 3, "prefectural"],
["楯岡", "浮沼", 3, "city"],
["楯岡", "河島", 2, "city"],
["湯沢", "行沢", 2, "mountain"],
["行沢", "中沢", 1, "mountain"],
["行沢", "新山", 1, "mountain"],
["北町", "大上林崎", 1, "city"],
["大上林崎", "行沢", 1, "mountain"],
["大上林崎", "金谷", 1, "city"],
["大上林崎", "名取", 2, "prefectural"],
["金谷", "本飯田", 2, "prefectural"],
["金谷", "境ノ目", 3, "mountain"],
["本飯田", "土生田", 2, "prefectural"],
["本飯田", "境ノ目", 3, "mountain"],
["土生田", "五十沢", 6, "highway"],
["土生田", "赤石高玉", 2, "city"],
["名取", "清水", 2, "city"],
["名取", "浮沼", 1, "city"],
["清水", "境ノ目", 2, "mountain"],
["浮沼", "清水", 2, "city"],
["浮沼", "大淀", 3, "prefectural"],
["浮沼", "大槇", 3, "city"],
["浮沼", "河島", 2, "city"],
["浮沼", "伝承館", 2, "city"],
["大淀", "長島", 2, "prefectural"],
["河島", "伝承館", 2, "city"],
["河島", "碁点", 2, "city"],
["碁点", "大槇", 1, "city"],
["碁点", "稲下", 2, "city"],
["碁点", "大久保", 2, "mountain"],
["大久保", "湯野沢", 2, "mountain"],
["湯野沢", "払平", 5, "mountain"],
["湯野沢", "岩野", 3, "mountain"],
["岩野", "葉山キャンプ場", 8, "mountain"],
["岩野", "樽石", 1, "mountain"],
["稲下", "長善寺", 1, "city"],
["稲下", "大久保", 2, "mountain"],
["長善寺", "白鳥", 2, "city"],
["長善寺", "大槇", 2, "city"],
["長善寺", "樽石", 2, "mountain"],
["樽石", "洗馬中", 4, "mountain"],
["洗馬中", "ふれあいの里", 2, "mountain"],
["大槇", "白鳥", 2, "city"],
["大槇", "長島", 3, "prefectural"],
["白鳥", "宮下", 1, "city"],
["白鳥", "長島", 2, "prefectural"],
["宮下", "長島", 2, "city"],
["長島", "小滝", 2, "city"],
["長島", "深沢", 2, "mountain"],
["小滝", "境ノ目", 1, "mountain"],
["小滝", "　森　", 1, "mountain"],
["境ノ目", "　森　", 1, "mountain"],
["富並", "深沢", 1, "mountain"],
["富並", "　森　", 2, "mountain"],
["富並", "下小屋", 3, "mountain"],
["下小屋", "枡沢", 2, "mountain"],
["下小屋", "大石", 2, "mountain"],
["大石", "清水平", 3, "mountain"],
["大石", "上平", 5, "mountain"],
["大石", "大鳥居", 1, "mountain"],
["大鳥居", "三枚平", 3, "mountain"]
// 隠し地点への接続例:
// ["隠し地点1", "楯岡", 2, "city"],  // このような形で隠し地点を既存の地点に接続
// ["隠し地点1", "名取", 3, "prefectural"]
];

// 道路種別の使用設定を取得する関数
function getRoadSettings() {
    return {
        avoidMountain: document.getElementById("avoidMountain").checked
    };
}

// 道路設定に基づいてグラフを構築
function buildFilteredGraph() {
    const roadSettings = getRoadSettings();
    const filteredGraph = {};
    
    for (let edge of edges) {
        const [a, b, d, roadType = "default"] = edge;
        
        // 山道を使用しない設定がONで、かつ道路種別が山道の場合はスキップ
        if (roadSettings.avoidMountain && roadType === "mountain") {
            continue;
        }
        
        if (!filteredGraph[a]) filteredGraph[a] = {};
        if (!filteredGraph[b]) filteredGraph[b] = {};
        filteredGraph[a][b] = d;
        filteredGraph[b][a] = d;
    }
    
    return filteredGraph;
}

// グラフを構築（隠し地点も含める）
let graph = {};
function updateGraph() {
    graph = buildFilteredGraph();
}

let start = null;
let end = null;
let shortestPath = [];
let allRouteResults = []; // 第三候補まで含む全ての経路結果
let showingAllPaths = false; // 全経路表示モードのフラグ
let selectedRouteIndex = 0; // 選択されている経路グループのインデックス
let selectedPathIndex = 0; // 選択されている経路のインデックス

// 地点が隠し地点かどうかチェック
function isHiddenNode(nodeName) {
    return hiddenNodes.hasOwnProperty(nodeName);
}

// 地点が選択可能かどうかチェック（通常の地点のみ選択可能）
function isSelectableNode(nodeName) {
    return nodes.hasOwnProperty(nodeName) && !isHiddenNode(nodeName);
}

// ビュー変換関数
function applyViewTransform() {
    ctx.save();
    ctx.translate(viewState.translateX, viewState.translateY);
    ctx.scale(viewState.scale, viewState.scale);
}

function restoreViewTransform() {
    ctx.restore();
}

// マウス座標をワールド座標に変換
function screenToWorld(screenX, screenY) {
    const rect = canvas.getBoundingClientRect();
    const canvasX = screenX - rect.left;
    const canvasY = screenY - rect.top;
    
    const worldX = (canvasX - viewState.translateX) / viewState.scale;
    const worldY = (canvasY - viewState.translateY) / viewState.scale;
    
    return { x: worldX, y: worldY };
}

function drawMap() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    applyViewTransform();
    
    const roadSettings = getRoadSettings();
    
    // 通常の道路を描画
    edges.forEach((edge) => {
        const [a, b, d, roadType = "default"] = edge;
        
        // 山道回避設定による表示制御
        let isRoadDisabled = false;
        if (roadSettings.avoidMountain && roadType === "mountain") {
            isRoadDisabled = true;
        }
        
        // 座標を取得（隠し地点も含む）
        const [x1, y1] = allNodes[a] || [0, 0];
        const [x2, y2] = allNodes[b] || [0, 0];
        
        let isInPath = false;
        let pathColors = [];
        
        if (showingAllPaths && allRouteResults.length > 0) {
            // 全経路表示モードの場合、各経路での使用状況をチェック
            if (allRouteResults.length === 1 && allRouteResults[0].paths.length > 1) {
                // 中継地点設定時：同じ距離の複数パターンを色分け
                allRouteResults[0].paths.forEach((path, pathIndex) => {
                    if (isEdgeInSpecificPath(a, b, path)) {
                        isInPath = true;
                        pathColors.push(getRouteDisplayColor(pathIndex));
                    }
                });
            } else {
                // 通常時：異なる距離の経路を色分け
                allRouteResults.forEach((routeGroup, groupIndex) => {
                    routeGroup.paths.forEach((path, pathIndex) => {
                        if (isEdgeInSpecificPath(a, b, path)) {
                            isInPath = true;
                            pathColors.push(getRouteDisplayColor(groupIndex));
                        }
                    });
                });
            }
        } else {
            // 通常モードの場合（選択された経路のみ表示）
            if (allRouteResults.length > 0 && selectedRouteIndex < allRouteResults.length) {
                const selectedRoute = allRouteResults[selectedRouteIndex];
                if (selectedRoute.paths.length > 0 && selectedPathIndex < selectedRoute.paths.length) {
                    isInPath = isEdgeInSpecificPath(a, b, selectedRoute.paths[selectedPathIndex]);
                }
            } else {
                isInPath = isEdgeInPath(a, b);
            }
        }
        
        // 道路の種類を取得
        const roadInfo = roadTypes[roadType] || roadTypes["default"];
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        
        // 線のスタイルを設定（経路・非経路に関わらず道路種別に応じて設定）
        if (roadInfo.style === "dashed") {
            ctx.setLineDash([5 / viewState.scale, 5 / viewState.scale]);
        } else if (roadInfo.style === "dotted") {
            ctx.setLineDash([2 / viewState.scale, 3 / viewState.scale]);
        } else {
            ctx.setLineDash([]); // 実線
        }
        
        if (isInPath) {
            // 経路表示は縁取りつきで視認性を向上
            if (showingAllPaths && pathColors.length > 1) {
                // 複数の経路で使用されている場合
                // 外側の縁取り（黒）
                ctx.strokeStyle = "black";
                ctx.lineWidth = 8 / viewState.scale;
                ctx.stroke();
                
                // 内側のメイン色（紫）
                ctx.strokeStyle = "#8e44ad";
                ctx.lineWidth = 6 / viewState.scale;
            } else if (showingAllPaths) {
                // 全経路表示時の個別色
                const mainColor = pathColors[0] || "#ffd700";
                
                // 外側の縁取り（黒）
                ctx.strokeStyle = "black";
                ctx.lineWidth = 6 / viewState.scale;
                ctx.stroke();
                
                // 内側のメイン色
                ctx.strokeStyle = mainColor;
                ctx.lineWidth = 4 / viewState.scale;
            } else {
                // 通常の経路表示
                // 外側の縁取り（黒）
                ctx.strokeStyle = "black";
                ctx.lineWidth = 6 / viewState.scale;
                ctx.stroke();
                
                // 内側のメイン色（黄色）
                ctx.strokeStyle = "#ffd700";
                ctx.lineWidth = 4 / viewState.scale;
            }
        } else {
            // 道路が無効化されている場合は薄く表示
            if (isRoadDisabled) {
                ctx.strokeStyle = "lightgray";
                ctx.lineWidth = (roadInfo.lineWidth * 0.5) / viewState.scale;
                ctx.setLineDash([3 / viewState.scale, 3 / viewState.scale]);
            } else {
                // 通常の道路表示（道路種別に応じた色と線幅）
                ctx.strokeStyle = roadInfo.color;
                ctx.lineWidth = roadInfo.lineWidth / viewState.scale;
            }
        }
        ctx.stroke();
        
        // 距離の表示（背景付きで視認性向上）
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        
        // エッジに垂直な方向にオフセット
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const offsetX = (-dy / length) * (8 / viewState.scale);
        const offsetY = (dx / length) * (8 / viewState.scale);
        
        const textX = midX + offsetX;
        const textY = midY + offsetY;
        
        ctx.font = `${12 / viewState.scale}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // 背景（白い丸）を描画
        const textWidth = ctx.measureText(d).width;
        const padding = 2 / viewState.scale;
        ctx.fillStyle = isRoadDisabled ? "rgba(200, 200, 200, 0.7)" : "rgba(255, 255, 255, 0.9)";
        ctx.beginPath();
        ctx.ellipse(textX, textY, (textWidth / 2) + padding, (6 / viewState.scale) + padding, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // テキストを描画
        ctx.fillStyle = isRoadDisabled ? "gray" : "black";
        ctx.fillText(d, textX, textY);
    });

    // ノードを描画（隠し地点は描画しない）
    for (let name in nodes) {
        if (isHiddenNode(name)) {
            continue; // 隠し地点はスキップ
        }
        
        const [x, y] = nodes[name];
        const radius = 10 / viewState.scale;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        
        let isInAnyPath = false;
        if (showingAllPaths) {
            isInAnyPath = allRouteResults.some(routeGroup => 
                routeGroup.paths.some(path => path.includes(name))
            );
        } else if (allRouteResults.length > 0 && selectedRouteIndex < allRouteResults.length) {
            const selectedRoute = allRouteResults[selectedRouteIndex];
            if (selectedRoute.paths.length > 0 && selectedPathIndex < selectedRoute.paths.length) {
                isInAnyPath = selectedRoute.paths[selectedPathIndex].includes(name);
            }
        } else {
            isInAnyPath = shortestPath.includes(name);
        }
        
        if (isInAnyPath) {
            ctx.strokeStyle = "orange";
            ctx.lineWidth = 3 / viewState.scale;
        } else {
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1 / viewState.scale;
        }
        
        ctx.fillStyle = (name === start) ? "green" : 
                       (name === end) ? "red" : 
                       (viaNodes.includes(name) ? "orange" : "lightblue");
        ctx.fill();
        
        // ノードの枠線は常に実線に戻す
        ctx.setLineDash([]);
        ctx.stroke();
        
        // ノード名を描画（背景付きで視認性向上）
        const textY = y - radius - (8 / viewState.scale);
        
        ctx.font = `${12 / viewState.scale}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // 背景（白い矩形）を描画
        const textWidth = ctx.measureText(name).width;
        const padding = 2 / viewState.scale;
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.fillRect(x - (textWidth / 2) - padding, textY - (6 / viewState.scale) - padding, 
                    textWidth + (padding * 2), (12 / viewState.scale) + (padding * 2));
        
        // テキストを描画
        ctx.fillStyle = "black";
        ctx.fillText(name, x, textY);
    }
    
    restoreViewTransform();
    
    // ズーム情報を更新
    document.getElementById("zoomInfo").textContent = `倍率: ${Math.round(viewState.scale * 100)}%`;
}

function isEdgeInPath(nodeA, nodeB) {
    if (shortestPath.length < 2) return false;
    return shortestPath.some((node, i) => {
        const next = shortestPath[i + 1];
        return next && ((node === nodeA && next === nodeB) || (node === nodeB && next === nodeA));
    });
}

function isEdgeInSpecificPath(nodeA, nodeB, path) {
    if (path.length < 2) return false;
    return path.some((node, i) => {
        const next = path[i + 1];
        return next && ((node === nodeA && next === nodeB) || (node === nodeB && next === nodeA));
    });
}

function getRouteColor(routeIndex) {
    const colors = ["yellow", "cyan", "lime"];
    return colors[routeIndex % colors.length];
}

// 全経路表示時の色マッピング
function getRouteDisplayColor(routeIndex) {
    const displayColors = {
        "yellow": "#ffd700",    // 金色
        "cyan": "#00bfff",      // 水色  
        "lime": "#32cd32"       // ライム
    };
    const colorKey = getRouteColor(routeIndex);
    return displayColors[colorKey] || "#ffd700";
}

// 数値を適切な精度で表示するヘルパー関数
function formatDistance(distance) {
    if (Number.isInteger(distance)) {
        return distance.toString();
    }
    // 小数点以下1桁まで表示し、不要な0を削除
    return parseFloat(distance.toFixed(1)).toString();
}

// 車賃（往復）を計算する関数
function calculateCarFare(distance) {
    const unitPrice = document.getElementById("carFare30").checked ? 30 : 25;
    const roundTripDistance = Math.floor(distance * 2); // 往復距離（小数点以下切り捨て）
    const carFare = roundTripDistance * unitPrice;
    
    return {
        unitPrice: unitPrice,
        roundTripDistance: roundTripDistance,
        carFare: carFare,
        calculation: `${formatDistance(distance)} × 2 = ${distance * 2} → ${roundTripDistance}km × ${unitPrice}円 = ${carFare.toLocaleString()}円`
    };
}

// 経路の詳細表示を生成する関数（隠し地点を除外）
function formatPathWithDistances(path) {
    if (path.length < 2) return path.filter(node => !isHiddenNode(node)).join(" → ");
    
    let result = "";
    let isFirst = true;
    let lastVisibleIndex = -1;
    
    for (let i = 0; i < path.length; i++) {
        const currentNode = path[i];
        
        // 隠し地点はスキップ
        if (isHiddenNode(currentNode)) {
            continue;
        }
        
        if (!isFirst && lastVisibleIndex >= 0) {
            // 前の表示地点からの累積距離を計算
            let accumulatedDistance = 0;
            
            for (let j = lastVisibleIndex; j < i; j++) {
                const fromNode = path[j];
                const toNode = path[j + 1];
                if (graph[fromNode] && graph[fromNode][toNode]) {
                    accumulatedDistance += graph[fromNode][toNode];
                }
            }
            
            result += ` → (${formatDistance(accumulatedDistance)}) → `;
        }
        
        result += currentNode;
        isFirst = false;
        lastVisibleIndex = i;
    }
    
    return result;
}

function updateViaNodeDisplay() {
    const span = document.getElementById("viaNodeList");
    if (viaNodes.length === 0) {
        span.textContent = "なし";
    } else {
        span.innerHTML = viaNodes.map(n => `${n} <button onclick="removeViaNode('${n}')">×</button>`).join(" / ");
    }
}

function removeViaNode(name) {
    const idx = viaNodes.indexOf(name);
    if (idx !== -1) {
        viaNodes.splice(idx, 1);
        updateViaNodeDisplay();
        drawMap();
    }
}

function clearAll() {
    start = null;
    end = null;
    viaNodes.length = 0;
    shortestPath = [];
    allRouteResults = [];
    showingAllPaths = false;
    selectedRouteIndex = 0;
    selectedPathIndex = 0;
    document.getElementById("startNode").textContent = "未選択";
    document.getElementById("endNode").textContent = "未選択";
    updateViaNodeDisplay();
    document.getElementById("result").textContent = "";
    drawMap();
}

function resetView() {
    viewState.scale = 1.0;
    viewState.translateX = 0;
    viewState.translateY = 0;
    drawMap();
}

// マウスイベントリスナー
canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const oldScale = viewState.scale;
    const newScale = Math.max(0.1, Math.min(5.0, viewState.scale * scaleFactor));
    
    // マウス位置を中心とした拡大縮小
    viewState.translateX = mouseX - (mouseX - viewState.translateX) * (newScale / oldScale);
    viewState.translateY = mouseY - (mouseY - viewState.translateY) * (newScale / oldScale);
    viewState.scale = newScale;
    
    drawMap();
});

canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const worldPos = screenToWorld(e.clientX, e.clientY);
    
    // ノードクリック判定（選択可能な地点のみ）
    let nodeClicked = false;
    for (let name in nodes) {
        if (!isSelectableNode(name)) {
            continue; // 隠し地点や選択不可地点はスキップ
        }
        
        const [nx, ny] = nodes[name];
        const dist = Math.hypot(nx - worldPos.x, ny - worldPos.y);
        if (dist < 15 / viewState.scale) {  // 10から15に拡大
            nodeClicked = true;
            
            if (!start) {
                start = name;
                document.getElementById("startNode").textContent = name;
            } else if (!end) {
                end = name;
                document.getElementById("endNode").textContent = name;
            } else if (viaNodes.includes(name)) {
                removeViaNode(name);
            } else if (viaNodes.length < MAX_VIA) {
                viaNodes.push(name);
                updateViaNodeDisplay();
            } else {
                start = name;
                end = null;
                viaNodes.length = 0;
                shortestPath = [];
                allRouteResults = [];
                document.getElementById("startNode").textContent = name;
                document.getElementById("endNode").textContent = "未選択";
                updateViaNodeDisplay();
                document.getElementById("result").textContent = "";
                document.getElementById("showAllPathsBtn").disabled = true;
            }
            drawMap();
            break;
        }
    }
    
    // ドラッグ開始
    if (!nodeClicked) {
        viewState.isDragging = true;
        viewState.lastMouseX = mouseX;
        viewState.lastMouseY = mouseY;
        canvas.style.cursor = "grabbing";
    }
});

canvas.addEventListener("mousemove", (e) => {
    if (viewState.isDragging) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const deltaX = mouseX - viewState.lastMouseX;
        const deltaY = mouseY - viewState.lastMouseY;
        
        viewState.translateX += deltaX;
        viewState.translateY += deltaY;
        
        viewState.lastMouseX = mouseX;
        viewState.lastMouseY = mouseY;
        
        drawMap();
    }
});

canvas.addEventListener("mouseup", () => {
    viewState.isDragging = false;
    canvas.style.cursor = "grab";
});

canvas.addEventListener("mouseleave", () => {
    viewState.isDragging = false;
    canvas.style.cursor = "grab";
});

// 修正版：K-shortest paths アルゴリズムを使用してトップ3の経路を取得
function findTopKPaths(startNode, endNode, k = 3) {
    // Yenのアルゴリズムを簡略化した実装
    const candidatePaths = [];
    const finalPaths = [];
    
    // 最初の最短経路を取得
    const firstPath = dijkstraPath(startNode, endNode);
    if (firstPath.path.length === 0 || firstPath.distance === Infinity) {
        return [];
    }
    
    finalPaths.push({
        path: firstPath.path,
        distance: firstPath.distance
    });
    
    let iterations = 0;
    const maxIterations = k * 20; // 無限ループ防止
    
    // k-1回繰り返して候補経路を生成
    for (let i = 1; i < k && iterations < maxIterations; i++) {
        const lastPath = finalPaths[i - 1];
        
        // 前の経路の各エッジを除去して新しい候補経路を生成
        for (let j = 0; j < lastPath.path.length - 1 && iterations < maxIterations; j++) {
            iterations++;
            
            const modifiedGraph = JSON.parse(JSON.stringify(graph));
            
            // 既存の経路の一部を除去
            for (let m = 0; m < finalPaths.length; m++) {
                const existingPath = finalPaths[m].path;
                for (let n = 0; n <= j && n < existingPath.length - 1; n++) {
                    if (existingPath[n] === lastPath.path[n] && existingPath[n + 1] === lastPath.path[n + 1]) {
                        // このエッジを除去
                        if (modifiedGraph[existingPath[n]]) {
                            delete modifiedGraph[existingPath[n]][existingPath[n + 1]];
                        }
                        if (modifiedGraph[existingPath[n + 1]]) {
                            delete modifiedGraph[existingPath[n + 1]][existingPath[n]];
                        }
                    }
                }
            }
            
            // 修正されたグラフで最短経路を計算
            const spurPath = dijkstraPathWithGraph(lastPath.path[j], endNode, modifiedGraph);
            if (spurPath.path.length > 0 && spurPath.distance < Infinity) {
                const rootPath = lastPath.path.slice(0, j + 1);
                const fullPath = [...rootPath, ...spurPath.path.slice(1)];
                const fullDistance = calculatePathDistance(fullPath);
                
                // 重複チェック
                const isDuplicate = candidatePaths.some(cp => 
                    JSON.stringify(cp.path) === JSON.stringify(fullPath)
                ) || finalPaths.some(fp => 
                    JSON.stringify(fp.path) === JSON.stringify(fullPath)
                );
                
                if (!isDuplicate && fullDistance < Infinity) {
                    candidatePaths.push({
                        path: fullPath,
                        distance: fullDistance
                    });
                }
            }
        }
        
        // 候補経路から最短のものを選択
        if (candidatePaths.length === 0) break;
        
        candidatePaths.sort((a, b) => a.distance - b.distance);
        const nextBest = candidatePaths.shift();
        finalPaths.push(nextBest);
    }
    
    return finalPaths;
}

// ダイクストラ法による最短経路計算
function dijkstraPath(startNode, endNode) {
    return dijkstraPathWithGraph(startNode, endNode, graph);
}

function dijkstraPathWithGraph(startNode, endNode, graphData) {
    const distances = {};
    const previous = {};
    const visited = new Set();
    const queue = [];

    // 開始ノードがグラフに存在しない場合
    if (!graphData[startNode] || !graphData[endNode]) {
        return { path: [], distance: Infinity };
    }

    // 初期化
    for (let node in graphData) {
        distances[node] = Infinity;
        previous[node] = null;
    }
    distances[startNode] = 0;
    queue.push(startNode);

    let iterations = 0;
    const maxIterations = Object.keys(graphData).length * 10; // 無限ループ防止

    while (queue.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // 最短距離のノードを選択
        queue.sort((a, b) => distances[a] - distances[b]);
        const current = queue.shift();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        if (current === endNode) break;

        // 隣接ノードが存在する場合のみ処理
        if (graphData[current]) {
            for (let neighbor in graphData[current]) {
                if (!visited.has(neighbor) && graphData[neighbor]) { // 隣接ノードがグラフに存在することを確認
                    const newDist = distances[current] + graphData[current][neighbor];
                    if (newDist < distances[neighbor]) {
                        distances[neighbor] = newDist;
                        previous[neighbor] = current;
                        if (!queue.includes(neighbor)) {
                            queue.push(neighbor);
                        }
                    }
                }
            }
        }
    }

    // 終了ノードに到達できない場合
    if (distances[endNode] === Infinity) {
        return { path: [], distance: Infinity };
    }

    // 経路を再構築
    const path = [];
    let current = endNode;
    while (current !== null) {
        path.unshift(current);
        current = previous[current];
    }

    if (path[0] !== startNode) {
        return { path: [], distance: Infinity };
    }

    return { path, distance: distances[endNode] };
}

// 経路の距離を計算
function calculatePathDistance(path) {
    let total = 0;
    for (let i = 0; i < path.length - 1; i++) {
        if (graph[path[i]] && graph[path[i]][path[i + 1]]) {
            total += graph[path[i]][path[i + 1]];
        } else {
            return Infinity;
        }
    }
    return total;
}

function shortestPathBetween(startNode, endNode) {
    const distances = {};
    const previous = {};
    const visited = {};
    const queue = [];

    // 開始ノードまたは終了ノードがグラフに存在しない場合
    if (!graph[startNode] || !graph[endNode]) {
        return { distance: Infinity, paths: [] };
    }

    for (let node in graph) {
        distances[node] = Infinity;
        previous[node] = [];
    }
    distances[startNode] = 0;
    queue.push(startNode);

    let iterations = 0;
    const maxIterations = Object.keys(graph).length * 10; // 無限ループ防止

    while (queue.length > 0 && iterations < maxIterations) {
        iterations++;
        
        queue.sort((a, b) => distances[a] - distances[b]);
        const current = queue.shift();
        if (visited[current]) continue;
        visited[current] = true;

        // 目標ノードに到達した場合は早期終了
        if (current === endNode) break;

        if (graph[current]) {
            for (let neighbor in graph[current]) {
                if (!visited[neighbor] && graph[neighbor]) { // 隣接ノードの存在を確認
                    const newDist = distances[current] + graph[current][neighbor];
                    if (newDist < distances[neighbor]) {
                        distances[neighbor] = newDist;
                        previous[neighbor] = [current];
                        if (!queue.includes(neighbor)) {
                            queue.push(neighbor);
                        }
                    } else if (newDist === distances[neighbor] && !previous[neighbor].includes(current)) {
                        previous[neighbor].push(current);
                    }
                }
            }
        }
    }

    // 終了ノードに到達できない場合
    if (distances[endNode] === Infinity) {
        return { distance: Infinity, paths: [] };
    }

    // 全ての最短経路を取得
    const allPaths = [];
    
    function buildPaths(node, currentPath) {
        if (node === startNode) {
            allPaths.push([startNode, ...currentPath.reverse()]);
            return;
        }
        
        for (let prev of previous[node]) {
            buildPaths(prev, [...currentPath, node]);
        }
    }
    
    if (distances[endNode] < Infinity) {
        buildPaths(endNode, []);
    }

    return {
        distance: distances[endNode],
        paths: allPaths
    };
}

function findAllShortestPaths(points) {
    let allCombinedPaths = [];
    let totalDistance = 0;
    
    // 各区間の全ての最短経路を取得
    const segmentPaths = [];
    for (let i = 0; i < points.length - 1; i++) {
        const { distance, paths } = shortestPathBetween(points[i], points[i + 1]);
        if (distance === Infinity || paths.length === 0) {
            return { distance: Infinity, paths: [] };
        }
        totalDistance += distance;
        segmentPaths.push(paths);
    }
    
    // 全区間の経路を組み合わせ
    function combinePaths(segmentIndex, currentPath) {
        if (segmentIndex >= segmentPaths.length) {
            allCombinedPaths.push([...currentPath]);
            return;
        }
        
        for (let path of segmentPaths[segmentIndex]) {
            const pathToAdd = segmentIndex === 0 ? path : path.slice(1);
            combinePaths(segmentIndex + 1, [...currentPath, ...pathToAdd]);
        }
    }
    
    combinePaths(0, []);
    
    return {
        distance: totalDistance,
        paths: allCombinedPaths
    };
}

// 複数の距離候補を含む経路計算（第三候補まで）
function findTopRoutes(points, maxRoutes = 3) {
    if (points.length === 2) {
        // 単純な2点間の場合
        return findTopKPaths(points[0], points[1], maxRoutes).map(result => ({
            distance: result.distance,
            paths: [result.path]
        }));
    } else {
        // 中継地点がある場合は、最短経路のみを計算
        const result = findAllShortestPaths(points);
        if (result.distance === Infinity) {
            return [];
        }
        return [{
            distance: result.distance,
            paths: result.paths
        }];
    }
}

function calculatePath() {
    if (!start || !end) {
        document.getElementById("result").textContent = "出発地点と到着地点を選択してください。";
        return;
    }

    // 道路設定に基づいてグラフを更新
    updateGraph();
    
    // グラフが空の場合（すべての道路種別が無効化された場合）
    if (Object.keys(graph).length === 0) {
        document.getElementById("result").textContent = "利用可能な道路がありません。道路種別の設定を確認してください。";
        shortestPath = [];
        allRouteResults = [];
        showingAllPaths = false;
        selectedRouteIndex = 0;
        selectedPathIndex = 0;
        drawMap();
        return;
    }

    // 選択された地点がグラフに接続されているかチェック
    const points = [start, ...viaNodes, end];
    for (let point of points) {
        if (!graph[point] || Object.keys(graph[point]).length === 0) {
            const roadSettings = getRoadSettings();
            let message = `「${point}」は他の地点と接続されていません。`;
            if (roadSettings.avoidMountain) {
                message += "\n山道を回避する設定により、この地点への経路がありません。";
                message += "\n設定を変更してみてください。";
            }
            document.getElementById("result").textContent = message;
            shortestPath = [];
            allRouteResults = [];
            showingAllPaths = false;
            selectedRouteIndex = 0;
            selectedPathIndex = 0;
            drawMap();
            return;
        }
    }

    const routeResults = findTopRoutes(points, 3);
    
    if (routeResults.length === 0) {
        const roadSettings = getRoadSettings();
        
        let message = "経路が見つかりませんでした。";
        if (roadSettings.avoidMountain) {
            message += "\n山道を回避する設定が有効になっています。";
            message += "\n設定を変更してみてください。";
        }
        
        document.getElementById("result").textContent = message;
        shortestPath = [];
        allRouteResults = [];
        showingAllPaths = false;
        selectedRouteIndex = 0;
        selectedPathIndex = 0;
        drawMap();
        return;
    }

    allRouteResults = routeResults;
    shortestPath = routeResults[0].paths[0]; // 最初の経路を表示用に設定
    showingAllPaths = false;
    selectedRouteIndex = 0;
    selectedPathIndex = 0;
    
    // 全経路表示ボタンを結果表示エリアに配置
    let resultText = `<div id="resultHeader">
        <h3>経路検索結果</h3>`;
    
    // 複数のルートグループがあるか、または同じ距離の複数経路がある場合にボタンを表示
    const hasMultipleRoutes = routeResults.length > 1 || 
                              (routeResults.length === 1 && routeResults[0].paths.length > 1);
    
    if (hasMultipleRoutes) {
        resultText += `<button id="showAllPathsBtn" onclick="showAllPaths()">全経路表示</button>`;
    }
    
    resultText += `</div>`;
    
    // 現在の道路設定を表示
    const roadSettings = getRoadSettings();
    if (roadSettings.avoidMountain) {
        resultText += `<p><small>設定: 山道を回避</small></p>`;
    }
    
    routeResults.forEach((routeGroup, groupIndex) => {
        const rankClass = `rank-${groupIndex + 1}`;
        const badgeClass = `${rankClass}-badge`;
        const rankLabel = groupIndex === 0 ? "最短" : groupIndex === 1 ? "第二候補" : "第三候補";
        const carFareInfo = calculateCarFare(routeGroup.distance);
        
        resultText += `<div class="path-list">`;
        resultText += `<h4><span class="rank-badge ${badgeClass}">${rankLabel}</span>距離: ${formatDistance(routeGroup.distance)}km　車賃（往復）: ${carFareInfo.carFare.toLocaleString()}円 <span style="font-size: 12px; color: #666;">（${carFareInfo.calculation}）</span></h4>`;
        
        if (routeGroup.paths.length === 1) {
            const isSelected = groupIndex === selectedRouteIndex && 0 === selectedPathIndex;
            resultText += `<div class="path-item ${rankClass} ${isSelected ? 'selected' : ''}" onclick="selectRoute(${groupIndex}, 0)">`;
            resultText += `${formatPathWithDistances(routeGroup.paths[0])}`;
            if (isSelected) {
                resultText += `<span class="selected-indicator">（選択中）</span>`;
            }
            resultText += `</div>`;
        } else {
            resultText += `<p>同じ距離の経路が${routeGroup.paths.length}つあります</p>`;
            routeGroup.paths.forEach((path, pathIndex) => {
                const isSelected = groupIndex === selectedRouteIndex && pathIndex === selectedPathIndex;
                resultText += `<div class="path-item ${rankClass} ${isSelected ? 'selected' : ''}" onclick="selectRoute(${groupIndex}, ${pathIndex})">`;
                resultText += `<strong>パターン${pathIndex + 1}:</strong> ${formatPathWithDistances(path)}`;
                if (isSelected) {
                    resultText += `<span class="selected-indicator">（選択中）</span>`;
                }
                resultText += `</div>`;
            });
        }
        resultText += `</div>`;
    });
    
    document.getElementById("result").innerHTML = resultText;
    drawMap();
}

function selectRoute(routeIndex, pathIndex) {
    selectedRouteIndex = routeIndex;
    selectedPathIndex = pathIndex;
    showingAllPaths = false;
    
    if (allRouteResults.length > routeIndex && allRouteResults[routeIndex].paths.length > pathIndex) {
        shortestPath = allRouteResults[routeIndex].paths[pathIndex];
        
        // 結果表示を更新して選択状態を反映
        updateResultDisplay();
    }
    
    drawMap();
}

function updateResultDisplay() {
    let resultText = `<div id="resultHeader">
        <h3>経路検索結果</h3>`;
    
    // 複数のルートグループがあるか、または同じ距離の複数経路がある場合にボタンを表示
    const hasMultipleRoutes = allRouteResults.length > 1 || 
                              (allRouteResults.length === 1 && allRouteResults[0].paths.length > 1);
    
    if (hasMultipleRoutes) {
        const showAllPathsClass = showingAllPaths ? 'active' : '';
        const buttonText = showingAllPaths ? '選択経路表示' : '全経路表示';
        resultText += `<button id="showAllPathsBtn" class="${showAllPathsClass}" onclick="showAllPaths()">${buttonText}</button>`;
    }
    
    resultText += `</div>`;
    
    // 現在の道路設定を表示
    const roadSettings = getRoadSettings();
    if (roadSettings.avoidMountain) {
        resultText += `<p><small>設定: 山道を回避</small></p>`;
    }
    
    allRouteResults.forEach((routeGroup, groupIndex) => {
        const rankClass = `rank-${groupIndex + 1}`;
        const badgeClass = `${rankClass}-badge`;
        const rankLabel = groupIndex === 0 ? "最短" : groupIndex === 1 ? "第二候補" : "第三候補";
        const carFareInfo = calculateCarFare(routeGroup.distance);
        
        resultText += `<div class="path-list">`;
        resultText += `<h4><span class="rank-badge ${badgeClass}">${rankLabel}</span>距離: ${formatDistance(routeGroup.distance)}km　車賃（往復）: ${carFareInfo.carFare.toLocaleString()}円 <span style="font-size: 12px; color: #666;">（${carFareInfo.calculation}）</span></h4>`;
        
        if (routeGroup.paths.length === 1) {
            const isSelected = groupIndex === selectedRouteIndex && 0 === selectedPathIndex;
            resultText += `<div class="path-item ${rankClass} ${isSelected ? 'selected' : ''}" onclick="selectRoute(${groupIndex}, 0)">`;
            resultText += `${formatPathWithDistances(routeGroup.paths[0])}`;
            if (isSelected) {
                resultText += `<span class="selected-indicator">（選択中）</span>`;
            }
            resultText += `</div>`;
        } else {
            resultText += `<p>同じ距離の経路が${routeGroup.paths.length}つあります</p>`;
            routeGroup.paths.forEach((path, pathIndex) => {
                const isSelected = groupIndex === selectedRouteIndex && pathIndex === selectedPathIndex;
                resultText += `<div class="path-item ${rankClass} ${isSelected ? 'selected' : ''}" onclick="selectRoute(${groupIndex}, ${pathIndex})">`;
                resultText += `<strong>パターン${pathIndex + 1}:</strong> ${formatPathWithDistances(path)}`;
                if (isSelected) {
                    resultText += `<span class="selected-indicator">（選択中）</span>`;
                }
                resultText += `</div>`;
            });
        }
        resultText += `</div>`;
    });
    
    document.getElementById("result").innerHTML = resultText;
}

function showAllPaths() {
    showingAllPaths = !showingAllPaths;
    const showAllPathsBtn = document.getElementById("showAllPathsBtn");
    
    if (showAllPathsBtn) {  // ボタンが存在する場合のみ処理
        if (showingAllPaths) {
            showAllPathsBtn.textContent = "選択経路表示";
            showAllPathsBtn.classList.add("active");
        } else {
            showAllPathsBtn.textContent = "全経路表示";
            showAllPathsBtn.classList.remove("active");
            // 全経路表示を無効にした場合、選択された経路を表示
            if (allRouteResults.length > 0) {
                if (allRouteResults[selectedRouteIndex] && allRouteResults[selectedRouteIndex].paths[selectedPathIndex]) {
                    shortestPath = allRouteResults[selectedRouteIndex].paths[selectedPathIndex];
                }
            }
        }
    }
    drawMap();
}

// 道路設定変更時のイベントリスナーを追加
function setupRoadSettingsListeners() {
    const checkboxes = ['avoidMountain', 'carFare30'];
    checkboxes.forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
            // 道路設定が変更されたら地図を再描画
            drawMap();
            
            // 既に経路が計算されている場合は再計算または結果表示更新
            if (start && end && (shortestPath.length > 0 || allRouteResults.length > 0)) {
                if (id === 'avoidMountain') {
                    calculatePath(); // 道路設定変更時は再計算
                } else if (id === 'carFare30') {
                    updateResultDisplay(); // 車賃設定変更時は表示更新のみ
                }
            }
        });
    });
}

// PDF出力機能
async function printPDF() {
    try {
        // 印刷用スタイルを直接インラインスタイルとして適用
        const originalStyles = new Map();
        
        // 適度なフォントサイズを直接適用
        const elementsToStyle = [
            { selector: '.path-list h4', styles: { fontSize: '15px', margin: '0 0 6px 0' } },
            { selector: '.path-item', styles: { fontSize: '13px', padding: '8px', margin: '4px 0', lineHeight: '1.4' } },
            { selector: '.rank-badge', styles: { fontSize: '12px', padding: '3px 6px' } },
            { selector: '#container', styles: { padding: '5px 10px', width: '100%' } },
            { selector: 'h1', styles: { fontSize: '18px', margin: '0 0 5px 0' } },
            { selector: '#mainContainer', styles: { gap: '10px', margin: '5px 0' } },
            { selector: '#mapContainer', styles: { width: '80%' } },
            { selector: '#rightPanel', styles: { width: '18%', minWidth: '150px', gap: '6px' } },
            { selector: '#info', styles: { padding: '8px', fontSize: '10px', marginBottom: '8px' } },
            { selector: '#info h4', styles: { fontSize: '12px', margin: '0 0 5px 0' } },
            { selector: '#roadOptions', styles: { padding: '8px', marginBottom: '8px' } },
            { selector: '#roadOptions h4', styles: { fontSize: '12px', margin: '0 0 5px 0' } },
            { selector: '#roadOptions label', styles: { fontSize: '10px' } },
            { selector: '#result', styles: { marginTop: '10px', marginBottom: '5px', paddingTop: '10px' } },
            { selector: '#resultHeader h3', styles: { fontSize: '14px', margin: '0 0 5px 0' } }
        ];
        
        // 要素を非表示にする（バージョンは表示したまま）
        const hideElements = ['#printButton', '#controls', '#operationInfo', '#zoomInfo', '#showAllPathsBtn'];
        
        // スタイルを適用し、元のスタイルを保存
        elementsToStyle.forEach(({ selector, styles }) => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                if (!originalStyles.has(element)) {
                    originalStyles.set(element, {});
                }
                const originalElementStyles = originalStyles.get(element);
                
                Object.keys(styles).forEach(property => {
                    originalElementStyles[property] = element.style[property];
                    element.style[property] = styles[property];
                });
            });
        });
        
        // 要素を非表示
        const hiddenElements = [];
        hideElements.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(element => {
                hiddenElements.push({ element, originalDisplay: element.style.display });
                element.style.display = 'none';
            });
        });
        
        // レイアウト調整
        const mainContainer = document.getElementById('mainContainer');
        const originalMainStyles = {
            display: mainContainer.style.display,
            flexDirection: mainContainer.style.flexDirection,
            alignItems: mainContainer.style.alignItems
        };
        mainContainer.style.display = 'flex';
        mainContainer.style.flexDirection = 'row';
        mainContainer.style.alignItems = 'flex-start';
        
        // レンダリング完了を待つ
        await new Promise(resolve => {
            requestAnimationFrame(() => {
                setTimeout(resolve, 300);
            });
        });
        
        // html2canvasでページをキャプチャ
        const canvas = await html2canvas(document.getElementById('container'), {
            scale: 1.5,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff',
            width: document.getElementById('container').scrollWidth,
            height: document.getElementById('container').scrollHeight,
            logging: false
        });
        
        // jsPDFでA4横サイズのPDFを作成
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'mm', 'a4');
        
        // A4横のサイズ (297mm x 210mm)
        const pdfWidth = 297;
        const pdfHeight = 210;
        
        // キャンバスの比率を計算
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const ratio = Math.min(pdfWidth / canvasWidth, pdfHeight / canvasHeight);
        
        // 画像サイズを計算
        const imgWidth = canvasWidth * ratio;
        const imgHeight = canvasHeight * ratio;
        
        // 中央配置のための位置計算
        const x = (pdfWidth - imgWidth) / 2;
        const y = (pdfHeight - imgHeight) / 2;
        
        // 画像をPDFに追加
        const imgData = canvas.toDataURL('image/png', 1.0);
        pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
        
        // PDFを保存
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;
        pdf.save(`路程計算_${timestamp}.pdf`);
        
        // 元のスタイルを復元
        originalStyles.forEach((elementStyles, element) => {
            Object.keys(elementStyles).forEach(property => {
                element.style[property] = elementStyles[property];
            });
        });
        
        // 非表示にした要素を復元
        hiddenElements.forEach(({ element, originalDisplay }) => {
            element.style.display = originalDisplay;
        });
        
        // mainContainerのスタイルを復元
        Object.keys(originalMainStyles).forEach(property => {
            mainContainer.style[property] = originalMainStyles[property];
        });
        
    } catch (error) {
        console.error('PDF生成エラー:', error);
        alert('PDF生成中にエラーが発生しました。ブラウザの印刷機能をお試しください。');
        window.print(); // フォールバック
    }
}

// 初期化
updateGraph(); // 初期グラフを構築
drawMap();
updateViaNodeDisplay();
setupRoadSettingsListeners(); // イベントリスナーを設定
</script>
</body>
</html>